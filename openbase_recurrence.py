# -*- coding: utf-8 -*-

##############################################################################
#    Copyright (C) 2012 SICLIC http://siclic.fr
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#############################################################################

import types
from openbase_core import OpenbaseCore, OpenbaseCoreWizard
from osv import fields, osv
from datetime import datetime, timedelta
import calendar
from dateutil import rrule
from dateutil import parser
from dateutil import relativedelta
import netsvc
import pytz
from tools.translate import _

"""
@note: Base implementation of recurrence used for OpenSTC modules
To use it with models, you can use inheritance : 
    * create a new model inheriting of this one (using _inherit)
    * override occurrence_ids to use a one2many on an existing model of your choice
    * override method 'prepare_occurrences' to customize data to be written on the 'occurence_ids' records
    * optionally, use _defaults attribute on your inheriting object to simplify setting of recurrence
    * to generate occurrences, use the method 'generate_dates' of your object on your views or xmlrpc calls

Or you can use this object directly (you'll use the objects defined here directly instead of custom ones): 
    * put a many2one to you're own object relating to this model
    * to generate occurrences, use the method 'generate_dates' of your many2one relating to this model
    
Or perhaps, a mixing of the two ways, such as using openbase.recurrence and an inheritance of openbase.recurrence.occurence,
but be careful of what you're doing
"""
class openbase_recurrence(OpenbaseCore):
    _name = 'openbase.recurrence'
    WEIGHT_SELECTION = [('first','First'),('second','Second'),('third','Third'),('fourth','Fourth'),('last','Last')]
    DAY_SELECTION = [('monday','Monday'),('tuesday','Tuesday'),('wednesday','Wednesday'),('thursday','Thursday'),('friday','Friday'),('saturday','Saturday'),('sunday','Sunday')]
    TYPE_RECUR = [('daily','Daily'),('weekly','Weekly'),('monthly','Monthly')]

    _columns = {
        'recur_periodicity':fields.integer('Periodicity'),
        'recur_week_monday':fields.boolean('Mon'),
        'recur_week_tuesday':fields.boolean('Tue'),
        'recur_week_wednesday':fields.boolean('Wed'),
        'recur_week_thursday':fields.boolean('Thu'),
        'recur_week_friday':fields.boolean('Fri'),
        'recur_week_saturday':fields.boolean('Sat'),
        'recur_week_sunday':fields.boolean('Sun'),
        'recur_month_type':fields.selection([('monthday','Month Day'),('monthweekday','Month Relative Weekday')]),
        'recur_month_absolute':fields.integer('Mounth day'),
        'recur_month_relative_weight':fields.selection(WEIGHT_SELECTION, 'Weight Month'),
        'recur_month_relative_day':fields.selection(DAY_SELECTION, 'Day month'),
        'recur_type':fields.selection(TYPE_RECUR,'Type'),
        'date_start':fields.datetime('First occurrence date', required=True),
        'recur_length_type':fields.selection([('count','Nb of occurrences'),('until','End date')], required=True),
        'date_end':fields.datetime('Last occurrence to generate', required=False),
        'recur_occurrence_nb':fields.integer('Nb of occurrences'),
        'occurrence_ids':fields.one2many('openbase.recurrence.occurrence', 'recurrence_id'),
        }

    _defaults = {
        'recur_periodicity':lambda *a: 1,
        'recur_type':lambda *a: 'daily',
        'recur_occurrence_nb':lambda *a: 1,
        }

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_daily_setting(self, cr, uid, date_start, weight, date_end=False, count=False, context=None):
        dates = []
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.DAILY, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.DAILY, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param weekdays: list of weekdays to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_weekly_setting(self, cr, uid, date_start, weight, weekdays, date_end=False, count=False, context=None):
        dates = []
        switch_date = {
            'monday':relativedelta.MO,
            'tuesday':relativedelta.TU,
            'wednesday':relativedelta.WE,
            'thursday':relativedelta.TH,
            'friday':relativedelta.FR,
            'saturday':relativedelta.SA,
            'sunday':relativedelta.SU
        }
        weekdays_todo = [switch_date.get(key) for key in weekdays if key in switch_date.keys()]

        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)

        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.WEEKLY, byweekday=weekdays_todo, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.WEEKLY, byweekday=weekdays_todo, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param day: integer between 1 and max day of a month (28-31)
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_daymonthly_setting(self, cr, uid, date_start, weight, day, date_end=False, count=False, context=None):
        dates = []
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.MONTHLY, bymonthday=day, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.MONTHLY, bymonthday=day, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param relative_position: must be one of 'first', 'second','third', 'fourth','last'
    @param weekday: must be one of 'monday','tuesday','wednesday', 'thursday', 'friday','saturday','sunday'
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_weekdaymonthly_setting(self, cr, uid, date_start, weight, relative_position, weekday, date_end=False, count=False, context=None):
        dates = []
        switch = {
                'first':1,
                'second':2,
                'third':3,
                'fourth':4,
                'last':-1
        }
        switch_date = {
            'monday':relativedelta.MO,
            'tuesday':relativedelta.TU,
            'wednesday':relativedelta.WE,
            'thursday':relativedelta.TH,
            'friday':relativedelta.FR,
            'saturday':relativedelta.SA,
            'sunday':relativedelta.SU
        }
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.MONTHLY, interval=weight, dtstart=date_start, until=until,
                                    byweekday=switch_date[weekday](switch[relative_position]))
        elif count:
            dates = rrule.rrule(rrule.MONTHLY, interval=weight, dtstart=date_start, count=count,
                                    byweekday=switch_date[weekday](switch[relative_position]))
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param id: id or recurrence to generate dates
    @return: list of tuple of checkin,checkout in standard format [('YYYY-mm-yy HH:MM:SS','YYYY-mm-yy HH:MM:SS')] with user Timezone
    @note: This method is used internally in OpenERP StandAlone, but could be used in xmlrpc call for custom UI
    => daily recurrence: repeat same resa each x days from date_start to date_end
    => weekly recurrence: repeat same resa for xxx,xxx,xxx weekdays each x weeks from date_start to date_end
    => monthly recurrence 1: repeat same resa each absolute day (the 3rd of each month) of a month each x months from date_start to date_end
    => monthly recurrence 2: repeat same resa each relative day (third Friday of each month)of a month each x months from date_start to date_end
    """
    def get_dates_from_setting(self, cr, uid, id, context=None):
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        recurrence = self.browse(cr, uid, id, context=context)
        dates = []
        weekday_items = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday']
        count = recurrence.recur_occurrence_nb if recurrence.recur_length_type == 'count' else False
        date_end = recurrence.date_end if recurrence.recur_length_type == 'until' else False
        if recurrence.recur_type == 'daily':
            dates = self.get_dates_from_daily_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, date_end=date_end, count=count, context=context)

        elif recurrence.recur_type == 'weekly':
            switch_date = {''}
            weekdays = [key for key in weekday_items if recurrence['recur_week_'+key]]
            dates = self.get_dates_from_weekly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, weekdays, date_end=date_end, count=count, context=context)
        
        elif recurrence.recur_type == 'monthly':
            if recurrence.recur_month_type == 'monthday':
                dates = self.get_dates_from_daymonthly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, 
                                   recurrence.recur_month_absolute, date_end=date_end, count=count, context=context)
                
            elif recurrence.recur_month_type == 'monthweekday':
                dates = self.get_dates_from_weekdaymonthly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, 
                   recurrence.recur_month_relative_weight, recurrence.recur_month_relative_day, date_end=date_end, count=count, context=context)
                
            else:
                raise osv.except_osv(_('Error'),_('You must provide a complete setting for once of monthly recurrence method'))
        else:
            raise osv.except_osv(_('Error'), _('You must set an existing type of recurrence'))
        ret = [pytz.timezone(context.get('tz')).localize(d.replace(tzinfo=None)) for d in dates]
        return ret
    
    """ @return: list of UTC dates (string) generated according to the setting of this record """
    def get_dates(self, cr, uid, id, context=None):
        #assert self._transient, 'Error: get_dates is only avaiable for Transient Recurrence models, use OpenbaseCoreWizard to declare such a model'
        dates = self.get_dates_from_setting(cr, uid, id, context=context)
        recurrence = self.browse(cr, uid, id, context=context)
        ret = [self.prepare_occurrences(cr, uid, recurrence, d, context=context) for d in dates]
        #delete transient record, because only used once to retrieve dates
        recurrence.unlink()
        return ret
    
    """ @return: dict of values used by 'generate_dates' method to build occurrences, can be override to customize behavior"""
    def prepare_occurrences(self, cr, uid, record, date, context=None):
        ret = {'date_start':date.astimezone(pytz.utc).strftime('%Y-%m-%d %H:%M:00'),
               'actions':['delete'],
        }
        return ret
    
    """ @return: True
    @note: create / replace occurrences with current settings"""
    def generate_dates(self, cr, uid, id, context=None):
        recurrence = self.browse(cr, uid, id, context=context)
        #first, remove all existing occurrences
        for occurrence in recurrence.occurrence_ids:
            occurrence.unlink(context=context)
        dates = self.get_dates_from_setting(cr, uid, recurrence.id, context=context)
        values = []
        for d in dates:
            values.append((0,0,self.prepare_occurrences(cr, uid, recurrence,d, context=context)))
        recurrence.write({'occurrence_ids':values},context=context)
        
        return True

openbase_recurrence()


class openbase_recurrence_occurrence(OpenbaseCore):
    _name = "openbase.recurrence.occurrence"
    _columns = {
        'date_start':fields.datetime('Date start', required=True),
        'date_end':fields.datetime('Date end', required=False),
        'recurrence_id':fields.many2one('openbase.recurrence', 'Recurrence'),
        }
    
openbase_recurrence_occurrence()
