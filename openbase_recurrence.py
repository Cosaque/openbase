# -*- coding: utf-8 -*-

##############################################################################
#    Copyright (C) 2012 SICLIC http://siclic.fr
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#############################################################################

import types
from openbase_core import OpenbaseCore
from osv import fields, osv
from datetime import datetime, timedelta
import calendar
from dateutil import rrule
from dateutil import parser
from dateutil import relativedelta
import netsvc
import pytz
from tools.translate import _


class openbase_recurrence(OpenbaseCore):
    _name = 'openbase.recurrence'
    WEIGHT_SELECTION = [('first','First'),('second','Second'),('third','Third'),('fourth','Fourth'),('last','Last')]
    DAY_SELECTION = [('monday','Monday'),('tuesday','Tuesday'),('wednesday','Wednesday'),('thursday','Thursday'),('friday','Friday'),('saturday','Saturday'),('sunday','Sunday')]
    TYPE_RECUR = [('daily','Daily'),('weekly','Weekly'),('monthly','Monthly')]

    _columns = {
        'recur_periodicity':fields.integer('Periodicity'),
        'recur_week_monday':fields.boolean('Mon'),
        'recur_week_tuesday':fields.boolean('Tue'),
        'recur_week_wednesday':fields.boolean('Wed'),
        'recur_week_thursday':fields.boolean('Thu'),
        'recur_week_friday':fields.boolean('Fri'),
        'recur_week_saturday':fields.boolean('Sat'),
        'recur_week_sunday':fields.boolean('Sun'),
        'recur_month_type':fields.selection([('monthday','Month Day'),('monthweekday','Month Relative Weekday')]),
        'recur_month_absolute':fields.integer('Mounth day'),
        'recur_month_relative_weight':fields.selection(WEIGHT_SELECTION, 'Weight Month'),
        'recur_month_relative_day':fields.selection(DAY_SELECTION, 'Day month'),
        'recur_type':fields.selection(TYPE_RECUR,'Type'),
        'date_start':fields.datetime('First occurrence date', required=True),
        'recur_length_type':fields.selection([('count','Nb of occurrences'),('until','End date')]),
        'date_end':fields.datetime('Last occurrence to generate', required=False),
        'recur_occurrence_nb':fields.integer('Nb of occurrences'),
        'occurrence_ids':fields.one2many('openbase.recurrence.occurrence', 'recurrence_id'),
        }

    _defaults = {
        'recur_periodicity':lambda *a: 1,
        'recur_type':lambda *a: 'daily',
        'recur_occurrence_nb':lambda *a: 1,
        }

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_daily_setting(self, cr, uid, date_start, weight, date_end=False, count=False, context=None):
        dates = []
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.DAILY, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.DAILY, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param weekdays: list of weekdays to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_weekly_setting(self, cr, uid, date_start, weight, weekdays, date_end=False, count=False, context=None):
        dates = []
        switch_date = {
            'monday':relativedelta.MO,
            'tuesday':relativedelta.TU,
            'wednesday':relativedelta.WE,
            'thursday':relativedelta.TH,
            'friday':relativedelta.FR,
            'saturday':relativedelta.SA,
            'sunday':relativedelta.SU
        }
        weekdays_todo = [switch_date.get(key) for key in weekdays if key in switch_date.keys()]

        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)

        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.WEEKLY, byweekday=weekdays_todo, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.WEEKLY, byweekday=weekdays_todo, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param day: integer between 1 and max day of a month (28-31)
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_daymonthly_setting(self, cr, uid, date_start, weight, day, date_end=False, count=False, context=None):
        dates = []
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.MONTHLY, bymonthday=day, interval=weight, dtstart=date_start, until=until)
        elif count:
            dates = rrule.rrule(rrule.MONTHLY, bymonthday=day, interval=weight, dtstart=date_start, count=count)
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param date_start: date from which to start recurrence
    @param weight: interval of recurrence (each 3 months for example)
    @param date_end: last_date to generate
    @param relative_position: must be one of 'first', 'second','third', 'fourth','last'
    @param weekday: must be one of 'monday','tuesday','wednesday', 'thursday', 'friday','saturday','sunday'
    @param count: nb of occurrences to generate
    @note: one of 'date_end' or 'count' parameter must be filled
    @return: list of dates (datetime.datetime generated by rrule python lib
    """
    def get_dates_from_weekdaymonthly_setting(self, cr, uid, date_start, weight, relative_position, weekday, date_end=False, count=False, context=None):
        dates = []
        switch = {
                'first':1,
                'second':2,
                'third':3,
                'fourth':4,
                'last':-1
        }
        switch_date = {
            'monday':relativedelta.MO,
            'tuesday':relativedelta.TU,
            'wednesday':relativedelta.WE,
            'thursday':relativedelta.TH,
            'friday':relativedelta.FR,
            'saturday':relativedelta.SA,
            'sunday':relativedelta.SU
        }
        if not context:
            context = self.pool.get('res.users').context_get(cr, uid, uid)
        date_start = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_start, '%Y-%m-%d %H:%M:%S'),context=context)
        if date_end:
            until = fields.datetime.context_timestamp(cr, uid, datetime.strptime(date_end, '%Y-%m-%d %H:%M:%S'),context=context)
            dates = rrule.rrule(rrule.MONTHLY, interval=weight, dtstart=date_start, until=until,
                                    byweekday=switch_date[weekday](switch[relative_position]))
        elif count:
            dates = rrule.rrule(rrule.MONTHLY, interval=weight, dtstart=date_start, count=count,
                                    byweekday=switch_date[weekday](switch[relative_position]))
        else:
            raise osv.except_osv(_('Error'), _('Missing parameter: date_end or count'))
        if dates:
            dates = list(dates)
        return dates

    """
    @param id: id or recurrence to generate dates
    @return: list of tuple of checkin,checkout in standard format [('YYYY-mm-yy HH:MM:SS','YYYY-mm-yy HH:MM:SS')] in UTC
    @note: This method is used internally in OpenERP StandAlone, but could be used in xmlrpc call for custom UI
    => daily recurrence: repeat same resa each x days from date_start to date_end
    => weekly recurrence: repeat same resa for xxx,xxx,xxx weekdays each x weeks from date_start to date_end
    => monthly recurrence 1: repeat same resa each absolute day (the 3rd of each month) of a month each x months from date_start to date_end
    => monthly recurrence 2: repeat same resa each relative day (third Friday of each month)of a month each x months from date_start to date_end
    """
    def get_dates_from_setting(self, cr, uid, id, context=None):
        recurrence = self.browse(cr, uid, id, context=context)
        dates = []
        count = recurrence.recur_occurrence_nb if recurrence.recur_length_type == 'count' else False
        date_end = recurrence.date_end if recurrence.recur_length_type == 'until' else False
        if recurrence.recur_type == 'daily':
            dates = self.get_dates_from_daily_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, date_end=date_end, count=count, context=context)

        elif recurrence.recur_type == 'weekly':
            weekdays = [val for key,val in switch_date.items() if recurrence['recur_week_'+key]]
            dates = self.get_dates_from_weekly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, weekdays, date_end=date_end, count=count, context=context)
        
        elif recurrence.recur_type == 'monthly':
            if recurrence.recur_month_type == 'monthday':
                dates = self.get_dates_from_daymonthly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, 
                                   recurrence.recur_month_absolute, date_end=date_end, count=count, context=context)
                
            elif recurrence.recur_month_type == 'monthweekday':
                dates = self.get_dates_from_weekdaymonthly_setting(cr, uid, recurrence.date_start, recurrence.recur_periodicity, 
                   recurrence.recur_month_relative_weight, recurrence.recur_month_relative_day, date_end=date_end, count=count, context=context)
                
            else:
                raise osv.except_osv(_('Error'),_('You must provide a complete setting for once of monthly recurrence method'))
        else:
            raise osv.except_osv(_('Error'), _('You must set an existing type of recurrence'))
        ret = list(dates)
        return ret

    """ @return: dict of values used by 'generate_dates' method to build occurrences, can be override to customize behavior"""
    def prepare_occurrences(self, cr, uid, record, date, context=None):
        return {'date_start':date.astimezone(pytz.utc).strftime('%Y-%m-%d %H:%M:00'),
                'recurrence_id':record.id}
    
    """ @return: True
    @note: create / replace occurrences with current settings"""
    def generate_dates(self, cr, uid, ids, context=None):
        if not isinstance(ids, list):
            ids = [ids]
        for recurrence in self.browse(cr, uid, ids, context=context):
            #first, remove all existing occurrences
            for occurrence in recurrence.occurrence_ids:
                occurrence.unlink(context=context)
            dates = self.get_dates_from_setting(cr, uid, recurrence.id, context=context)
            values = []
            for d in dates:
                values.append((0,0,self.prepare_occurrences(cr, uid, recurrence,d, context=context)))
            recurrence.write({'occurrence_ids':values},context=context)
        return True

openbase_recurrence()


class openbase_recurrence_occurrence(OpenbaseCore):
    _name = "openbase.recurrence.occurrence"
    _columns = {
        'date_start':fields.datetime('Date start', required=True),
        'date_end':fields.datetime('Date end', required=False),
        'recurrence_id':fields.many2one('openbase.recurrence', 'Recurrence'),
        }
    
openbase_recurrence_occurrence()